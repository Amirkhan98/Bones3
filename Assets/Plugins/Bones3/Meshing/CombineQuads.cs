using Unity.Collections;
using Unity.Jobs;

namespace WraithavenGames.Bones3.Meshing
{
    /// <summary>
    /// This job takes in a set of quads for a given chunk side and combines them into an array
    /// of larger quads for further processing.
    /// </summary>
    public struct CombineQuads : IJob
    {
        /// <summary>
        /// An array of each quad face which is present within the chunk. This array consists
        /// of boolean values representing whether quadsIn[(x * 16 * 16 + y * 16 + z) * 6 + j]
        /// is an active face or not.
        /// </summary>
        [ReadOnly]
        public NativeArray<byte> quadsIn;

        /// <summary>
        /// The generated list of combined quads.
        /// </summary>
        public NativeArray<Quad> quadsOut;

        /// <summary>
        /// The number of quads generated by this job. Equal to length 1.
        /// </summary>
        public NativeArray<int> quadCount;

        /// <summary>
        /// Used for internal storage when processing the quads. 16 * 16 in length.
        /// </summary>
        public NativeArray<byte> storage;

        public void Execute()
        {
            for (int j = 0; j < 6; j++)
                for (int layer = 0; layer < 16; layer++)
                    GreedyMesher(layer, j);
        }

        private void ResetStorage()
        {
            for (int i = 0; i < 16 * 16; i++)
                storage[i] = 0;
        }

        private int GetIndex(int layer, int x, int y, int side)
        {
            switch (side)
            {
                case 0:
                case 1:
                    return (layer * 16 * 16 + x * 16 + y) * 6 + side;

                case 2:
                case 3:
                    return (x * 16 * 16 + layer * 16 + y) * 6 + side;

                case 4:
                case 5:
                    return (x * 16 * 16 + y * 16 + layer) * 6 + side;
            }

            return -1;
        }

        private void BuildColumns(int layer, int side)
        {
            byte total = 1;
            for (int y = 0; y < 16; y++)
            {
                byte w = 0;
                for (int x = 0; x < 16; x++)
                {
                    if (quadsIn[GetIndex(layer, x, y, side)] == 0)
                    {
                        w = 0;
                        continue;
                    }

                    if (w == 0)
                    {
                        w = total;
                        total++;
                    }

                    storage[x * 16 + y] = w;
                }
            }
        }

        private void CombineColumns()
        {
            for (int y = 0; y < 15; y++)
            {
                int w = 0;
                for (int x = 0; x < 16; x++)
                {
                    if (storage[x * 16 + y] == 0)
                    {
                        if (w > 0)
                        {
                            if (storage[x * 16 + (y + 1)] == 0 && (x == w || storage[(x - w - 1) * 16 + (y + 1)] == 0))
                            {
                                int q = 0;

                                for (int t = x - w; t < x; t++)
                                {
                                    if (storage[t * 16 + (y + 1)] == 0)
                                        break;

                                    q++;
                                }

                                if (q == w)
                                    for (int t = x - w; t < x; t++)
                                        storage[t * 16 + (y + 1)] = storage[t * 16 + y];
                            }
                            w = 0;
                        }
                        continue;
                    }
                    w++;
                }

                if (w > 0)
                {
                    if (16 == w || storage[(16 - w - 1) * 16 + (y + 1)] == 0)
                    {
                        int q = 0;

                        for (int t = 16 - w; t < 16; t++)
                        {
                            if (storage[t * 16 + (y + 1)] == 0)
                                break;

                            q++;
                        }

                        if (q == w)
                            for (int t = 16 - w; t < 16; t++)
                                storage[t * 16 + (y + 1)] = storage[t * 16 + y];
                    }
                }
            }
        }

        private void AddQuads(int offset, int side)
        {
            int lastQuad = 0;
            for (int y = 0; y < 16; y++)
            {
                for (int x = 0; x < 16; x++)
                {
                    int type = storage[x * 16 + y];
                    if (type > lastQuad)
                    {
                        lastQuad = type;

                        int w;
                        for (w = x; w < 16; w++)
                            if (storage[w * 16 + y] != type)
                                break;
                        w -= x;

                        int h;
                        for (h = y; h < 16; h++)
                            if (storage[x * 16 + h] != type)
                                break;
                        h -= y;

                        quadsOut[quadCount[0]++] = new Quad()
                        {
                            x = x,
                            y = y,
                            w = w,
                            h = h,
                            side = side,
                            offset = offset
                        };
                    }
                }
            }
        }

        private void GreedyMesher(int layer, int side)
        {
            ResetStorage();

            BuildColumns(layer, side);
            CombineColumns();

            AddQuads(layer, side);
        }
    }
}