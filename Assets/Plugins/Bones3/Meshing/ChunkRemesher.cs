using UnityEngine;
using Unity.Collections;
using Unity.Jobs;
using System.Collections.Generic;
using WraithavenGames.Bones3.BlockProperties;

namespace WraithavenGames.Bones3.Meshing
{
    /// <summary>
    /// The <c>ChunkRemesher</c> is a MonoBehavior which acts as a remesh manager. It simply passes
    /// along chunk remesh requests to the job system, and each frame, once the requests are complete,
    /// the corresponding chunks are updated in Unity.
    /// 
    /// TODO Add support for allowing processing of collision meshes in main thread. This is useful
    /// for preventing collision and physics errors if chunks are slow to generate.
    /// </summary>
    public class ChunkRemesher : MonoBehaviour
    {
        private List<RemeshRequest> requests = new List<RemeshRequest>();

        public void AddRequest(Chunk chunk)
        {
            requests.Add(new RemeshRequest(chunk));
        }

        void FixedUpdate()
        {
            // TODO Check if chunk requests are ready for use.
        }
    }

    /// <summary>
    /// A <c>RemeshRequest</c> is a queued request for regenerating a chunk. It represents a chunk
    /// who's remesh jobs have already been submitted are are waiting to be finished so the Unity
    /// game objects can be updated accordingly.
    /// </summary>
    class RemeshRequest
    {
        /// <summary>
        /// This constant represents the maximum number of quads that can be generated by a chunk in
        /// the worst case senario. This value is used for allocating memory.
        /// </summary>
        private const int MAX_QUADS = 16 * 16 * 8 * 6;

        /// <summary>
        /// The chunk which is being updated.
        /// </summary>
        Chunk chunk;

        /// <summary>
        /// A list of all remesh stubs which were created by this chunk update.
        /// </summary>
        List<RemeshStub> stubs = new List<RemeshStub>();

        private NativeArray<BlockID> blockProperties;

        public RemeshRequest(Chunk chunk)
        {
            this.chunk = chunk;

            var blocks = new ushort[4096];
            var blockRef = new List<ushort>();

            for (int i = 0; i < 4096; i++)
            {
                blocks[i] = chunk.GetBlockID(i);

                if (!blockRef.Contains(blocks[i]))
                    blockRef.Add(blocks[i]);
            }

            BlockID[] blockIDs = new BlockID[blockRef.Count];
            for (int i = 0; i < blockIDs.Length; i++)
            {
                MaterialBlock blockState = chunk.GetBlockState(i);

                BlockID id = new BlockID();
                blockIDs[i] = id;
                id.id = blocks[i];
                id.hasCollision = blocks[i] > 0;
                id.transparent = blockState.Transparent;
                id.viewInsides = blockState.ViewInsides;
                id.depthSort = blockState.DepthSort;

                blockRef.Add(blocks[i]);
            }
            blockProperties = new NativeArray<BlockID>(blockIDs, Allocator.TempJob);

            CreateCollisionRemeshStub(blocks);
        }

        private void Dispose()
        {
            blockProperties.Dispose();
        }

        private void CreateCollisionRemeshStub(ushort[] blocks)
        {
            var vertices = new NativeArray<Vector3>(MAX_QUADS * 4, Allocator.TempJob);
            var normals = new NativeArray<Vector3>(MAX_QUADS * 4, Allocator.TempJob);
            var triangles = new NativeArray<ushort>(MAX_QUADS * 6, Allocator.TempJob);

            RemeshCollisionJob remeshCollision = new RemeshCollisionJob(blocks, blockProperties, vertices, normals, triangles);
            JobHandle job = remeshCollision.Schedule();

            stubs.Add(new RemeshStub(vertices, normals, triangles, job));
        }

        private void CreateMaterialRemeshStubs(ushort[] blocks, BlockID[] blockIDs)
        {
            for (int i = 0; i < blockIDs.Length; i++)
            {
                ushort id = blockIDs[i].id;

                var vertices = new NativeArray<Vector3>(MAX_QUADS * 4, Allocator.TempJob);
                var normals = new NativeArray<Vector3>(MAX_QUADS * 4, Allocator.TempJob);
                var uvs = new NativeArray<Vector2>(MAX_QUADS * 4, Allocator.TempJob);
                var triangles = new NativeArray<ushort>(MAX_QUADS * 6, Allocator.TempJob);

                RemeshMaterialJob remeshMaterial = new RemeshMaterialJob(blocks, blockProperties, id, vertices, normals, uvs, triangles);
                JobHandle job = remeshMaterial.Schedule();

                Material material = chunk.BlockTypes.GetMaterialProperties(id).Material;
                stubs.Add(new RemeshStubMaterial(vertices, normals, uvs, triangles, material, job));
            }
        }
    }

    /// <summary>
    /// A remesh stub is a single chunk mesh which is generated by a remesh job. As each chunk can
    /// contain multiple meshes, (one for each block material plus one for the collision), the chunk
    /// contains multiple corresponding remesh stubs.
    /// 
    /// The base <c>RemeshStub</c> is used for generating the collision mesh while the
    /// <c>RemeshStubMaterial</c> is used for generating material submeshes.
    /// </summary>
    class RemeshStub
    {
        /// <summary>
        /// A list of vertex locations for this mesh. If empty, this vertex data object represents an
        /// empty mesh.
        /// </summary>
        protected NativeArray<Vector3> vertices;

        /// <summary>
        /// A list of normal values for this mesh.
        /// </summary>
        protected NativeArray<Vector3> normals;

        /// <summary>
        /// A list of vertex indices, representing the triangles for this mesh. Each triplet of indices
        /// represents a single triangle.
        /// </summary>
        protected NativeArray<ushort> triangles;

        /// <summary>
        /// The job handle which this stub is waiting on.
        /// </summary>
        protected JobHandle job;

        public RemeshStub(NativeArray<Vector3> vertices, NativeArray<Vector3> normals, NativeArray<ushort> triangles,
            JobHandle job)
        {
            this.vertices = vertices;
            this.normals = normals;
            this.triangles = triangles;
            this.job = job;
        }
    }

    /// <summary>
    /// A <c>RemeshStubMaterial</c> is an extention of a <c>RemeshStub</c> which adds support for handling
    /// a material submesh.
    /// </summary>
    class RemeshStubMaterial : RemeshStub
    {
        /// <summary>
        /// A list of uv values for this mesh.
        /// </summary>
        protected NativeArray<Vector2> uvs;

        /// <summary>
        /// The material which this submesh represents.
        /// </summary>
        protected Material material;

        public RemeshStubMaterial(NativeArray<Vector3> vertices, NativeArray<Vector3> normals, NativeArray<Vector2> uvs,
            NativeArray<ushort> triangles, Material material, JobHandle job) : base(vertices, normals, triangles, job)
        {
            this.uvs = uvs;
            this.material = material;
        }
    }
}
